
<!DOCTYPE html>
<html>
<head>
    <h1></h1>
    <title>BGP Neighbor Analysis</title>
    <link rel="stylesheet" type="text/css" href="/css/styles2.css">
    <style>
        .bgp-excellent { color: #4caf50; font-weight: bold; }
        .bgp-good { color: #8bc34a; font-weight: bold; }
        .bgp-warning { color: #ff9800; font-weight: bold; }
        .bgp-critical { color: #f44336; font-weight: bold; }
        .bgp-unknown { color: gray; }
        .bgp-table { width: 100%; border-collapse: collapse; margin: 20px 0; }
        .bgp-table th, .bgp-table td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        .bgp-table th { background-color: #f2f2f2; }
        
        /* Sortable table styling */
        .sortable {
            cursor: pointer;
            user-select: none;
            position: relative;
            padding-right: 20px;
        }
        
        .sortable:hover {
            background-color: #f5f5f5;
        }
        
        .sort-arrow {
            font-size: 10px;
            color: #999;
            margin-left: 5px;
            opacity: 0.5;
        }
        
        .sortable.asc .sort-arrow::before {
            content: '▲';
            color: #b57614;
            opacity: 1;
        }
        
        .sortable.desc .sort-arrow::before {
            content: '▼';
            color: #b57614;
            opacity: 1;
        }
        
        .sortable.asc .sort-arrow,
        .sortable.desc .sort-arrow {
            opacity: 1;
        }
        .summary-grid { 
            display: grid; 
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); 
            gap: 15px; 
            margin: 20px 0; 
        }
        .summary-card { 
            background: #f8f9fa; 
            padding: 15px; 
            border-radius: 8px; 
            border-left: 4px solid #007bff; 
        }
        .metric { font-size: 24px; font-weight: bold; }
        .state-established { color: #4caf50; font-weight: bold; }
        .state-idle { color: #f44336; font-weight: bold; }
        .state-active { color: #f44336; font-weight: bold; }
        .state-connect { color: #f44336; font-weight: bold; }
        .uptime-good { color: #4caf50; }
        .uptime-warning { color: #ff9800; }
        .uptime-critical { color: #f44336; }
        
        .summary-card {
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .summary-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        .summary-card.active {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.25);
            border-left-width: 6px;
        }
        
        .filter-info {
            text-align: center;
            padding: 10px;
            margin: 10px 0;
            background: #e8f4fd;
            border-radius: 4px;
            color: #1976d2;
            display: none;
        }
    </style>
</head>
<body>
    <h1><font color="#b57614">BGP Neighbor Analysis</font></h1>
    <p><strong>Last Updated:</strong> 2025-08-06 00:06:04</p>
    
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 style="margin: 0;">Network Summary</h2>
        <button id="download-csv" onclick="downloadCSV()" 
                style="background: #4caf50; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 14px; display: flex; align-items: center; gap: 8px; transition: all 0.3s ease;"
                onmouseover="this.style.background='#45a049'" 
                onmouseout="this.style.background='#4caf50'">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                <path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z"/>
            </svg>
            Download CSV
        </button>
    </div>
    <div class="summary-grid">
        <div class="summary-card" id="total-devices-card">
            <div class="metric" id="total-devices">0</div>
            <div>BGP Devices</div>
        </div>
        <div class="summary-card" id="total-neighbors-card">
            <div class="metric" id="total-neighbors">0</div>
            <div>Total Neighbors</div>
        </div>
        <div class="summary-card" id="established-card">
            <div class="metric bgp-excellent" id="established-neighbors">0</div>
            <div>Established</div>
        </div>
        <div class="summary-card" id="down-card">
            <div class="metric bgp-critical" id="down-neighbors">0</div>
            <div>Down/Problem</div>
        </div>
        <div class="summary-card" id="health-card">
            <div class="metric" id="health-ratio">0.0%</div>
            <div>Health Ratio</div>
        </div>
    </div>

    <h2>BGP Neighbors Status (0 total)</h2>
    <div id="filter-info" class="filter-info">
        <span id="filter-text"></span>
        <button onclick="clearFilter()" style="margin-left: 10px; padding: 2px 8px; background: #1976d2; color: white; border: none; border-radius: 3px; cursor: pointer;">Show All</button>
    </div>
    <table class="bgp-table" id="bgp-table">
        <thead>
        <tr>
            <th class="sortable" data-column="0" data-type="string">
                Device <span class="sort-arrow">▲▼</span>
            </th>
            <th class="sortable" data-column="1" data-type="string">
                Neighbor <span class="sort-arrow">▲▼</span>
            </th>
            <th class="sortable" data-column="2" data-type="port">
                Interface <span class="sort-arrow">▲▼</span>
            </th>
            <th class="sortable" data-column="3" data-type="bgp-state">
                State <span class="sort-arrow">▲▼</span>
            </th>
            <th class="sortable" data-column="4" data-type="number">
                ASN <span class="sort-arrow">▲▼</span>
            </th>
            <th class="sortable" data-column="5" data-type="uptime">
                Uptime <span class="sort-arrow">▲▼</span>
            </th>
            <th class="sortable" data-column="6" data-type="ratio">
                Prefixes RX/TX <span class="sort-arrow">▲▼</span>
            </th>
            <th class="sortable" data-column="7" data-type="ratio">
                Messages RX/TX <span class="sort-arrow">▲▼</span>
            </th>
            <th class="sortable" data-column="8" data-type="ratio">
                Queue In/Out <span class="sort-arrow">▲▼</span>
            </th>
            <th class="sortable" data-column="9" data-type="bgp-health">
                Health <span class="sort-arrow">▲▼</span>
            </th>
        </tr>
        </thead>
        <tbody id="bgp-data">

        </tbody>
    </table>
    
    <h2>BGP Health Thresholds</h2>
    <table class="bgp-table">
        <tr><th>Parameter</th><th>Threshold</th><th>Description</th></tr>
        <tr><td>Critical Down Time</td><td>1+ hours</td><td>Neighbor down for extended period</td></tr>
        <tr><td>High Queue Depth</td><td>10+ messages</td><td>Processing delays or congestion</td></tr>
        <tr><td>Low Prefix Count</td><td>&lt; 1 prefix</td><td>Potential route advertisement issues</td></tr>
        <tr><td>Message Ratio</td><td>&lt; 80%</td><td>Imbalanced message exchange</td></tr>
    </table>

    <script>
        // Filter functionality
        let currentFilter = 'ALL';
        let allRows = [];
        
        document.addEventListener('DOMContentLoaded', function() {
            // Store all table rows for filtering
            allRows = Array.from(document.querySelectorAll('#bgp-data tr'));
            
            // Add click events to summary cards
            setupCardEvents();
            
            // Initialize table sorting
            initTableSorting();
        });
        
        function setupCardEvents() {
            document.getElementById('total-devices-card').addEventListener('click', function() {
                if (parseInt(document.getElementById('total-devices').textContent) > 0) {
                    filterNeighbors('TOTAL');
                }
            });
            
            document.getElementById('total-neighbors-card').addEventListener('click', function() {
                if (parseInt(document.getElementById('total-neighbors').textContent) > 0) {
                    filterNeighbors('TOTAL');
                }
            });
            
            document.getElementById('established-card').addEventListener('click', function() {
                if (parseInt(document.getElementById('established-neighbors').textContent) > 0) {
                    filterNeighbors('ESTABLISHED');
                }
            });
            
            document.getElementById('down-card').addEventListener('click', function() {
                if (parseInt(document.getElementById('down-neighbors').textContent) > 0) {
                    filterNeighbors('DOWN');
                }
            });
        }
        
        function filterNeighbors(filterType) {
            currentFilter = filterType;
            
            // Clear active state from all cards
            document.querySelectorAll('.summary-card').forEach(card => {
                card.classList.remove('active');
            });
            
            let filteredRows = allRows;
            let filterText = '';
            
            if (filterType === 'ESTABLISHED') {
                filteredRows = allRows.filter(row => row.dataset.state === 'established');
                filterText = `Showing ${filteredRows.length} Established Neighbors`;
                document.getElementById('established-card').classList.add('active');
            } else if (filterType === 'DOWN') {
                filteredRows = allRows.filter(row => 
                    row.dataset.state !== 'established' || 
                    row.dataset.health === 'critical' || 
                    row.dataset.health === 'warning'
                );
                filterText = `Showing ${filteredRows.length} Down/Problem Neighbors`;
                document.getElementById('down-card').classList.add('active');
            } else if (filterType === 'TOTAL') {
                filteredRows = allRows;
                document.getElementById('total-neighbors-card').classList.add('active');
            }
            
            // Show filter info for all filters except TOTAL
            if (filterType !== 'ALL' && filterType !== 'TOTAL') {
                document.getElementById('filter-info').style.display = 'block';
                document.getElementById('filter-text').textContent = filterText;
            } else {
                document.getElementById('filter-info').style.display = 'none';
            }
            
            // Hide all rows first
            allRows.forEach(row => row.style.display = 'none');
            
            // Show filtered rows
            filteredRows.forEach(row => row.style.display = '');
        }
        
        function clearFilter() {
            currentFilter = 'ALL';
            document.querySelectorAll('.summary-card').forEach(card => {
                card.classList.remove('active');
            });
            document.getElementById('filter-info').style.display = 'none';
            
            // Show all rows
            allRows.forEach(row => row.style.display = '');
        }

        // Generic table sorting functionality  
        let tableSortState = { column: -1, direction: 'asc' };
        
        function initTableSorting() {
            const headers = document.querySelectorAll('.sortable');
            headers.forEach(header => {
                header.addEventListener('click', function() {
                    const column = parseInt(this.dataset.column);
                    const type = this.dataset.type;
                    
                    // Toggle sort direction
                    if (tableSortState.column === column) {
                        tableSortState.direction = tableSortState.direction === 'asc' ? 'desc' : 'asc';
                    } else {
                        tableSortState.direction = 'asc';
                    }
                    tableSortState.column = column;
                    
                    // Update header styling
                    headers.forEach(h => h.classList.remove('asc', 'desc'));
                    this.classList.add(tableSortState.direction);
                    
                    // Sort table
                    sortBGPTable(column, tableSortState.direction, type);
                });
            });
        }
        
        function sortBGPTable(columnIndex, direction, type) {
            const table = document.getElementById('bgp-table');
            const tbody = table.querySelector('tbody');
            const rows = Array.from(tbody.rows);
            
            rows.sort((a, b) => {
                let aVal = a.cells[columnIndex].textContent.trim();
                let bVal = b.cells[columnIndex].textContent.trim();
                
                // Extract actual text for status/health columns (remove HTML)
                if (type === 'bgp-state' || type === 'bgp-health') {
                    aVal = a.cells[columnIndex].querySelector('span')?.textContent || aVal;
                    bVal = b.cells[columnIndex].querySelector('span')?.textContent || bVal;
                }
                
                let result = 0;
                
                switch(type) {
                    case 'number':
                        result = parseInt(aVal) - parseInt(bVal);
                        break;
                    case 'port':
                        result = comparePort(aVal, bVal);
                        break;
                    case 'uptime':
                        result = compareBGPUptime(aVal, bVal);
                        break;
                    case 'bgp-state':
                        result = compareBGPState(aVal, bVal);
                        break;
                    case 'bgp-health':
                        result = compareBGPHealth(aVal, bVal);
                        break;
                    case 'ratio':
                        result = compareRatio(aVal, bVal);
                        break;
                    case 'string':
                    default:
                        result = aVal.localeCompare(bVal, undefined, { numeric: true, sensitivity: 'base' });
                        break;
                }
                
                return direction === 'desc' ? -result : result;
            });
            
            // Clear tbody and add sorted rows back
            tbody.innerHTML = '';
            rows.forEach(row => tbody.appendChild(row));
        }
        
        function comparePort(a, b) {
            if (a === 'N/A') return 1;
            if (b === 'N/A') return -1;
            
            // Handle port sorting (swp1, swp10, swp1s0, etc.)
            const extractPortNumber = (port) => {
                const match = port.match(/swp(\d+)(?:s(\d+))?/);
                if (match) {
                    const mainPort = parseInt(match[1]);
                    const subPort = match[2] ? parseInt(match[2]) : 0;
                    return mainPort * 1000 + subPort;
                }
                return port.localeCompare(b, undefined, { numeric: true });
            };
            
            return extractPortNumber(a) - extractPortNumber(b);
        }
        
        function compareBGPUptime(a, b) {
            if (a === 'never') return 1;
            if (b === 'never') return -1;
            
            // Parse BGP uptime format (e.g., "1d23h", "00:30:45", etc.)
            const parseUptime = (uptime) => {
                let minutes = 0;
                
                // Handle format like "1d23h", "2w3d", etc.
                const weekMatch = uptime.match(/(\d+)w/);
                const dayMatch = uptime.match(/(\d+)d/);
                const hourMatch = uptime.match(/(\d+)h/);
                
                if (weekMatch) minutes += parseInt(weekMatch[1]) * 7 * 24 * 60;
                if (dayMatch) minutes += parseInt(dayMatch[1]) * 24 * 60;
                if (hourMatch) minutes += parseInt(hourMatch[1]) * 60;
                
                // Handle HH:MM:SS format
                const timeMatch = uptime.match(/(\d+):(\d+):(\d+)/);
                if (timeMatch) {
                    minutes += parseInt(timeMatch[1]) * 60; // hours
                    minutes += parseInt(timeMatch[2]); // minutes
                }
                
                return minutes;
            };
            
            return parseUptime(a) - parseUptime(b);
        }
        
        function compareBGPState(a, b) {
            const priority = {
                'IDLE': 0,
                'ACTIVE': 1,
                'CONNECT': 2,
                'ESTABLISHED': 3
            };
            
            return (priority[a] || 4) - (priority[b] || 4);
        }
        
        function compareBGPHealth(a, b) {
            const priority = {
                'CRITICAL': 0,
                'WARNING': 1,
                'GOOD': 2,
                'EXCELLENT': 3
            };
            
            return (priority[a] || 4) - (priority[b] || 4);
        }
        
        function compareRatio(a, b) {
            // Parse ratio like "100/200" and compare by first number
            const getRatioValue = (ratio) => {
                const parts = ratio.split('/');
                return parseInt(parts[0]) || 0;
            };
            
            return getRatioValue(a) - getRatioValue(b);
        }

        // CSV Download Function
        function downloadCSV() {
            try {
                // Get current date for filename
                const now = new Date();
                const dateStr = now.toISOString().slice(0, 10); // YYYY-MM-DD
                const timeStr = now.toTimeString().slice(0, 5).replace(':', '-'); // HH-MM
                const filename = `BGP_Analysis_Report_${dateStr}_${timeStr}.csv`;
                
                // Create CSV header
                const headers = [
                    'Device',
                    'Neighbor', 
                    'Interface',
                    'State',
                    'ASN',
                    'Uptime',
                    'Prefixes RX/TX',
                    'Messages RX/TX',
                    'Queue In/Out',
                    'Health'
                ];
                
                let csvContent = headers.join(',') + '\n';
                
                // Get table data (only visible rows)
                const table = document.getElementById('bgp-table');
                const tbody = table.querySelector('tbody');
                const rows = tbody.querySelectorAll('tr');
                
                // Add summary stats as comments
                csvContent += `# BGP Analysis Summary Report\n`;
                csvContent += `# Generated: ${now.toLocaleString()}\n`;
                csvContent += `# Total Devices: ${document.getElementById('total-devices').textContent}\n`;
                csvContent += `# Total Neighbors: ${document.getElementById('total-neighbors').textContent}\n`;
                csvContent += `# Established: ${document.getElementById('established-neighbors').textContent}\n`;
                csvContent += `# Down/Problem: ${document.getElementById('down-neighbors').textContent}\n`;
                csvContent += `# Health Ratio: ${document.getElementById('health-ratio').textContent}\n`;
                csvContent += `#\n`;
                
                // Process each visible row
                rows.forEach(row => {
                    if (row.style.display !== 'none') {
                        const cells = row.querySelectorAll('td');
                        if (cells.length >= 10) {
                            const rowData = [
                                cells[0].textContent.trim(), // Device
                                cells[1].textContent.trim(), // Neighbor
                                cells[2].textContent.trim(), // Interface
                                cells[3].textContent.trim(), // State
                                cells[4].textContent.trim(), // ASN
                                cells[5].textContent.trim(), // Uptime
                                cells[6].textContent.trim(), // Prefixes RX/TX
                                cells[7].textContent.trim(), // Messages RX/TX
                                cells[8].textContent.trim(), // Queue In/Out
                                cells[9].textContent.trim()  // Health
                            ];
                            
                            // Escape commas and quotes in data
                            const escapedData = rowData.map(field => {
                                if (field.includes(',') || field.includes('"') || field.includes('\n')) {
                                    return '"' + field.replace(/"/g, '""') + '"';
                                }
                                return field;
                            });
                            
                            csvContent += escapedData.join(',') + '\n';
                        }
                    }
                });
                
                // Create and trigger download
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.style.display = 'none';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                console.log(`✅ CSV downloaded: ${filename}`);
                
            } catch (error) {
                console.error('❌ Error generating CSV:', error);
                alert('Error generating CSV file. Please try again.');
            }
        }

    </script>
</body>
</html>
